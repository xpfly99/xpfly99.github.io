<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>跨域问题</title>
      <link href="/2023/03/13/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/13/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="Java如何解决跨域问题？"><a href="#Java如何解决跨域问题？" class="headerlink" title="Java如何解决跨域问题？"></a><strong>Java如何解决跨域问题？</strong></h4><p>​我们在开发过程中经常会遇到<a href="https://so.csdn.net/so/search?q=%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB&spm=1001.2101.3001.7020">前后端分离</a>而导致的跨域问题，导致无法获取返回结果。跨域就像分离前端和后端的一道鸿沟，君在这边，她在那边，两两不能往来.</p><p><strong>什么是跨域</strong></p><p>跨域（CORS）是指不同域名之间相互访问。跨域，指的是浏览器不能执行其他网站的脚本，它是由浏览器的<a href="https://so.csdn.net/so/search?q=%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5&spm=1001.2101.3001.7020">同源策略</a>所造成的，是浏览器对于JavaScript所定义的安全限制策略。</p><p><strong>什么情况下会跨域</strong></p><ul><li>同一协议， 如http或https</li><li>同一IP地址, 如127.0.0.1</li><li>同一端口, 如8080</li></ul><p>以上三个条件中有一个条件不同就会产生跨域问题。</p><p><strong>前端解决方案</strong></p><p>​1.使用JSONP方式实现跨域调用；</p><p>​2.使用NodeJS服务器做为服务代理，前端发起请求到NodeJS服务器， NodeJS服务器代理转发请求到后端服务器；</p><p><strong>后端解决方案</strong></p><p>​1.Nginx反向代理解决跨域问题</p><p>​2.使用使用@CrossOrigin注解，在需要跨域访问的类和方法中设置允许跨域访问(标注在controller类的方法上或者controller类上)</p><p>​<strong>在controller使用</strong></p><pre><code>@CrossOrigin@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123;@GetMapping(&quot;/&#123;id&#125;&quot;)public User get(@PathVariable Long id) &#123;    &#125;@DeleteMapping(&quot;/&#123;id&#125;&quot;)public void remove(@PathVariable Long id) &#123;    &#125;&#125;</code></pre><p>​<strong>在具体接口上使用</strong></p><pre><code>@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123;    @CrossOrigin    @GetMapping(&quot;/&#123;id&#125;&quot;)    public User get(@PathVariable Long id) &#123;            &#125;    @DeleteMapping(&quot;/&#123;id&#125;&quot;)    public void remove(@PathVariable Long id) &#123;    &#125;&#125;</code></pre><p>​3.继承使用Spring Web的CorsFilter（适用于Spring MVC、Spring Boot）</p><p>​</p><pre><code>import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;import java.util.Collections;import java.util.List;@Configurationpublic class CorsConfig &#123;    @Bean    public CorsFilter corsFilter() &#123;        CorsConfiguration corsConfiguration = new CorsConfiguration();        //1,允许任何来源，这里可以线上填写具体允许的域名        corsConfiguration.setAllowedOriginPatterns(Collections. singletonList(&quot;*&quot;));        //2,允许任何请求头        corsConfiguration.addAllowedHeader(CorsConfiguration.ALL);        //3,允许任何方法        corsConfiguration.addAllowedMethod(CorsConfiguration.ALL);        //4,允许凭证        corsConfiguration.setAllowCredentials(true);        UrlBasedCorsConfigurationSource source = new    UrlBasedCorsConfigurationSource();        source.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration);        return new CorsFilter(source);    &#125;&#125;</code></pre><p>​4.实现WebMvcConfigurer接口（适用于Spring Boot）</p><pre><code>//标注这个类是一个配置类@Configuration//实现 WebMvcConfigurer 接口public class CorsConfig implements WebMvcConfigurer &#123;    @Override    public void addCorsMappings(CorsRegistry registry) &#123;         registry.addMapping(&quot;/**&quot;)  //设置允许跨域访问的路径                .allowedOriginPatterns(&quot;*&quot;)  //设置允许跨域访问的源                .allowedMethods(&quot;*&quot;)  //允许跨域请求的方法                .maxAge(168000)  //预检间隔时间                .allowedHeaders(&quot;*&quot;)  //允许头部设置                .allowCredentials(true);  //是否发送 cookie    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
